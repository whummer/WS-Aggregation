[1]	Module	::=	VersionDecl? (LibraryModule | MainModule)
[2]	VersionDecl	::=	"xquery" (("encoding" StringLiteral) | ("version" StringLiteral ("encoding" StringLiteral)?)) Separator
[3]	MainModule	::=	Prolog QueryBody
[4]	LibraryModule	::=	ModuleDecl Prolog
[5]	ModuleDecl	::=	"module" "namespace" NCName "=" URILiteral Separator
[6]	Prolog	::=	((DefaultNamespaceDecl | Setter | NamespaceDecl | Import) Separator)* ((ContextItemDecl | AnnotatedDecl | OptionDecl) Separator)*
[7]	Separator	::=	";"
[8]	Setter	::=	BoundarySpaceDecl | DefaultCollationDecl | BaseURIDecl | ConstructionDecl | OrderingModeDecl | EmptyOrderDecl | CopyNamespacesDecl | DecimalFormatDecl
[9]	BoundarySpaceDecl	::=	"declare" "boundary-space" ("preserve" | "strip")
[10]	DefaultCollationDecl	::=	"declare" "default" "collation" URILiteral
[11]	BaseURIDecl	::=	"declare" "base-uri" URILiteral
[12]	ConstructionDecl	::=	"declare" "construction" ("strip" | "preserve")
[13]	OrderingModeDecl	::=	"declare" "ordering" ("ordered" | "unordered")
[14]	EmptyOrderDecl	::=	"declare" "default" "order" "empty" ("greatest" | "least")
[15]	CopyNamespacesDecl	::=	"declare" "copy-namespaces" PreserveMode "," InheritMode
[16]	PreserveMode	::=	"preserve" | "no-preserve"
[17]	InheritMode	::=	"inherit" | "no-inherit"
[18]	DecimalFormatDecl	::=	"declare" (("decimal-format" EQName) | ("default" "decimal-format")) (DFPropertyName "=" StringLiteral)*
[19]	DFPropertyName	::=	"decimal-separator" | "grouping-separator" | "infinity" | "minus-sign" | "NaN" | "percent" | "per-mille" | "zero-digit" | "digit" | "pattern-separator"
[20]	Import	::=	SchemaImport | ModuleImport
[21]	SchemaImport	::=	"import" "schema" SchemaPrefix? URILiteral ("at" URILiteral ("," URILiteral)*)?
[22]	SchemaPrefix	::=	("namespace" NCName "=") | ("default" "element" "namespace")
[23]	ModuleImport	::=	"import" "module" ("namespace" NCName "=")? URILiteral ("at" URILiteral ("," URILiteral)*)?
[24]	NamespaceDecl	::=	"declare" "namespace" NCName "=" URILiteral
[25]	DefaultNamespaceDecl	::=	"declare" "default" ("element" | "function") "namespace" URILiteral
[26]	AnnotatedDecl	::=	"declare" Annotation* (VarDecl | FunctionDecl)
[27]	Annotation	::=	"%" EQName ("(" Literal ("," Literal)* ")")?
[28]	VarDecl	::=	"variable" "$" VarName TypeDeclaration? ((":=" VarValue) | ("external" (":=" VarDefaultValue)?))
[29]	VarValue	::=	ExprSingle
[30]	VarDefaultValue	::=	ExprSingle
[31]	ContextItemDecl	::=	"declare" "context" "item" ("as" ItemType)? ((":=" VarValue) | ("external" (":=" VarDefaultValue)?))
[32]	FunctionDecl	::=	"function" EQName "(" ParamList? ")" ("as" SequenceType)? (FunctionBody | "external") /* xgc: reserved-function-namesXQ30 */
[33]	ParamList	::=	Param ("," Param)*
[34]	Param	::=	"$" EQName TypeDeclaration?
[35]	FunctionBody	::=	EnclosedExpr
[36]	EnclosedExpr	::=	"{" Expr "}"
[37]	OptionDecl	::=	"declare" "option" EQName StringLiteral
[38]	QueryBody	::=	Expr
[39]	Expr	::=	ExprSingle ("," ExprSingle)*
[40]	ExprSingle	::=	FLWORExpr | QuantifiedExpr | SwitchExpr | TypeswitchExpr | IfExpr | TryCatchExpr | OrExpr
[41]	FLWORExpr	::=	InitialClause IntermediateClause* ReturnClause
[42]	InitialClause	::=	ForClause | LetClause | WindowClause
[43]	IntermediateClause	::=	InitialClause | WhereClause | GroupByClause | OrderByClause | CountClause
[44]	ForClause	::=	"for" ForBinding ("," ForBinding)*
[45]	ForBinding	::=	"$" VarName TypeDeclaration? AllowingEmpty? PositionalVar? "in" ExprSingle
[46]	AllowingEmpty	::=	"allowing" "empty"
[47]	PositionalVar	::=	"at" "$" VarName
[48]	LetClause	::=	"let" LetBinding ("," LetBinding)*
[49]	LetBinding	::=	"$" VarName TypeDeclaration? ":=" ExprSingle
[50]	WindowClause	::=	"for" (TumblingWindowClause | SlidingWindowClause)
[51]	TumblingWindowClause	::=	"tumbling" "window" "$" VarName TypeDeclaration? "in" ExprSingle WindowStartCondition WindowEndCondition?
[52]	SlidingWindowClause	::=	"sliding" "window" "$" VarName TypeDeclaration? "in" ExprSingle WindowStartCondition WindowEndCondition
[53]	WindowStartCondition	::=	"start" WindowVars "when" ExprSingle
[54]	WindowEndCondition	::=	"only"? "end" WindowVars "when" ExprSingle
[55]	WindowVars	::=	("$" CurrentItem)? PositionalVar? ("previous" "$" PreviousItem)? ("next" "$" NextItem)?
[56]	CurrentItem	::=	EQName
[57]	PreviousItem	::=	EQName
[58]	NextItem	::=	EQName
[59]	CountClause	::=	"count" "$" VarName
[60]	WhereClause	::=	"where" ExprSingle
[61]	GroupByClause	::=	"group" "by" GroupingSpecList
[62]	GroupingSpecList	::=	GroupingSpec ("," GroupingSpec)*
[63]	GroupingSpec	::=	"$" VarName ("collation" URILiteral)?
[64]	OrderByClause	::=	(("order" "by") | ("stable" "order" "by")) OrderSpecList
[65]	OrderSpecList	::=	OrderSpec ("," OrderSpec)*
[66]	OrderSpec	::=	ExprSingle OrderModifier
[67]	OrderModifier	::=	("ascending" | "descending")? ("empty" ("greatest" | "least"))? ("collation" URILiteral)?
[68]	ReturnClause	::=	"return" ExprSingle
[69]	QuantifiedExpr	::=	("some" | "every") "$" VarName TypeDeclaration? "in" ExprSingle ("," "$" VarName TypeDeclaration? "in" ExprSingle)* "satisfies" ExprSingle
[70]	SwitchExpr	::=	"switch" "(" Expr ")" SwitchCaseClause+ "default" "return" ExprSingle
[71]	SwitchCaseClause	::=	("case" SwitchCaseOperand)+ "return" ExprSingle
[72]	SwitchCaseOperand	::=	ExprSingle
[73]	TypeswitchExpr	::=	"typeswitch" "(" Expr ")" CaseClause+ "default" ("$" VarName)? "return" ExprSingle
[74]	CaseClause	::=	"case" ("$" VarName "as")? SequenceTypeUnion "return" ExprSingle
[75]	SequenceTypeUnion	::=	SequenceType ("|" SequenceType)*
[76]	IfExpr	::=	"if" "(" Expr ")" "then" ExprSingle "else" ExprSingle
[77]	TryCatchExpr	::=	TryClause CatchClause+
[78]	TryClause	::=	"try" "{" TryTargetExpr "}"
[79]	TryTargetExpr	::=	Expr
[80]	CatchClause	::=	"catch" CatchErrorList CatchVars? "{" Expr "}"
[81]	CatchErrorList	::=	NameTest ("|" NameTest)*
[82]	CatchVars	::=	"(" CatchErrorCode ("," CatchErrorDesc ("," CatchErrorVal)?)? ")"
[83]	CatchErrorCode	::=	"$" VarName
[84]	CatchErrorDesc	::=	"$" VarName
[85]	CatchErrorVal	::=	"$" VarName
[86]	OrExpr	::=	AndExpr ( "or" AndExpr )*
[87]	AndExpr	::=	ComparisonExpr ( "and" ComparisonExpr )*
[88]	ComparisonExpr	::=	RangeExpr ( (ValueComp | GeneralComp | NodeComp) RangeExpr )?
[89]	RangeExpr	::=	AdditiveExpr ( "to" AdditiveExpr )?
[90]	AdditiveExpr	::=	MultiplicativeExpr ( ("+" | "-") MultiplicativeExpr )*
[91]	MultiplicativeExpr	::=	UnionExpr ( ("*" | "div" | "idiv" | "mod") UnionExpr )*
[92]	UnionExpr	::=	IntersectExceptExpr ( ("union" | "|") IntersectExceptExpr )*
[93]	IntersectExceptExpr	::=	InstanceofExpr ( ("intersect" | "except") InstanceofExpr )*
[94]	InstanceofExpr	::=	TreatExpr ( "instance" "of" SequenceType )?
[95]	TreatExpr	::=	CastableExpr ( "treat" "as" SequenceType )?
[96]	CastableExpr	::=	CastExpr ( "castable" "as" SingleType )?
[97]	CastExpr	::=	UnaryExpr ( "cast" "as" SingleType )?
[98]	UnaryExpr	::=	("-" | "+")* ValueExpr
[99]	ValueExpr	::=	ValidateExpr | PathExpr | ExtensionExpr
[100]	GeneralComp	::=	"=" | "!=" | "<" | "<=" | ">" | ">="
[101]	ValueComp	::=	"eq" | "ne" | "lt" | "le" | "gt" | "ge"
[102]	NodeComp	::=	"is" | "<<" | ">>"
[103]	ValidateExpr	::=	"validate" (ValidationMode | ("type" TypeName))? "{" Expr "}"
[104]	ValidationMode	::=	"lax" | "strict"
[105]	ExtensionExpr	::=	Pragma+ "{" Expr? "}"
[106]	Pragma	::=	"(#" S? EQName (S PragmaContents)? "#)" /* ws: explicitXQ30 */
[107]	PragmaContents	::=	(Char* - (Char* '#)' Char*))
[108]	PathExpr	::=	("/" RelativePathExpr?) | ("//" RelativePathExpr) | RelativePathExpr /* xgc: leading-lone-slashXQ30 */
[109]	RelativePathExpr	::=	StepExpr (("/" | "//") StepExpr)*
[110]	StepExpr	::=	PostfixExpr | AxisStep
[111]	AxisStep	::=	(ReverseStep | ForwardStep) PredicateList
[112]	ForwardStep	::=	(ForwardAxis NodeTest) | AbbrevForwardStep
[113]	ForwardAxis	::=	("child" "::") | ("descendant" "::") | ("attribute" "::") | ("self" "::") | ("descendant-or-self" "::") | ("following-sibling" "::") | ("following" "::")
[114]	AbbrevForwardStep	::=	"@"? NodeTest
[115]	ReverseStep	::=	(ReverseAxis NodeTest) | AbbrevReverseStep
[116]	ReverseAxis	::=	("parent" "::") | ("ancestor" "::") | ("preceding-sibling" "::") | ("preceding" "::") | ("ancestor-or-self" "::")
[117]	AbbrevReverseStep	::=	".."
[118]	NodeTest	::=	KindTest | NameTest
[119]	NameTest	::=	EQName | Wildcard
[120]	Wildcard	::=	"*" | (NCName ":" "*") | ("*" ":" NCName) /* ws: explicitXQ30 */
[121]	PostfixExpr	::=	PrimaryExpr (Predicate | ArgumentList)*
[122]	ArgumentList	::=	"(" (Argument ("," Argument)*)? ")"
[123]	PredicateList	::=	Predicate*
[124]	Predicate	::=	"[" Expr "]"
[125]	PrimaryExpr	::=	Literal | VarRef | ParenthesizedExpr | ContextItemExpr | FunctionCall | OrderedExpr | UnorderedExpr | Constructor | FunctionItemExpr
[126]	Literal	::=	NumericLiteral | StringLiteral
[127]	NumericLiteral	::=	IntegerLiteral | DecimalLiteral | DoubleLiteral
[128]	VarRef	::=	"$" VarName
[129]	VarName	::=	EQName
[130]	ParenthesizedExpr	::=	"(" Expr? ")"
[131]	ContextItemExpr	::=	"."
[132]	OrderedExpr	::=	"ordered" "{" Expr "}"
[133]	UnorderedExpr	::=	"unordered" "{" Expr "}"
[134]	FunctionCall	::=	EQName ArgumentList /* xgc: reserved-function-namesXQ30 */ /* gn: parensXQ30 */
[135]	Argument	::=	ExprSingle | ArgumentPlaceholder
[136]	ArgumentPlaceholder	::=	"?"
[137]	Constructor	::=	DirectConstructor | ComputedConstructor
[138]	DirectConstructor	::=	DirElemConstructor | DirCommentConstructor | DirPIConstructor
[139]	DirElemConstructor	::=	"<" QName DirAttributeList ("/>" | (">" DirElemContent* "</" QName S? ">")) /* ws: explicitXQ30 */
[140]	DirAttributeList	::=	(S (QName S? "=" S? DirAttributeValue)?)* /* ws: explicitXQ30 */
[141]	DirAttributeValue	::=	('"' (EscapeQuot | QuotAttrValueContent)* '"') | ("'" (EscapeApos | AposAttrValueContent)* "'") /* ws: explicitXQ30 */
[142]	QuotAttrValueContent	::=	QuotAttrContentChar | CommonContent
[143]	AposAttrValueContent	::=	AposAttrContentChar | CommonContent
[144]	DirElemContent	::=	DirectConstructor | CDataSection | CommonContent | ElementContentChar
[145]	CommonContent	::=	PredefinedEntityRef | CharRef | "{{" | "}}" | EnclosedExpr
[146]	DirCommentConstructor	::=	"<!--" DirCommentContents "-->" /* ws: explicitXQ30 */
[147]	DirCommentContents	::=	((Char - '-') | ('-' (Char - '-')))* /* ws: explicitXQ30 */
[148]	DirPIConstructor	::=	"<?" PITarget (S DirPIContents)? "?>" /* ws: explicitXQ30 */
[149]	DirPIContents	::=	(Char* - (Char* '?>' Char*)) /* ws: explicitXQ30 */
[150]	CDataSection	::=	"<![CDATA[" CDataSectionContents "]]>" /* ws: explicitXQ30 */
[151]	CDataSectionContents	::=	(Char* - (Char* ']]>' Char*)) /* ws: explicitXQ30 */
[152]	ComputedConstructor	::=	CompDocConstructor | CompElemConstructor | CompAttrConstructor | CompNamespaceConstructor | CompTextConstructor | CompCommentConstructor | CompPIConstructor
[153]	CompDocConstructor	::=	"document" "{" Expr "}"
[154]	CompElemConstructor	::=	"element" (EQName | ("{" Expr "}")) "{" ContentExpr? "}"
[155]	ContentExpr	::=	Expr
[156]	CompAttrConstructor	::=	"attribute" (EQName | ("{" Expr "}")) "{" Expr? "}"
[157]	CompNamespaceConstructor	::=	"namespace" (Prefix | ("{" PrefixExpr "}")) "{" URIExpr? "}"
[158]	Prefix	::=	NCName
[159]	PrefixExpr	::=	Expr
[160]	URIExpr	::=	Expr
[161]	CompTextConstructor	::=	"text" "{" Expr "}"
[162]	CompCommentConstructor	::=	"comment" "{" Expr "}"
[163]	CompPIConstructor	::=	"processing-instruction" (NCName | ("{" Expr "}")) "{" Expr? "}"
[164]	FunctionItemExpr	::=	LiteralFunctionItem | InlineFunction
[165]	LiteralFunctionItem	::=	EQName "#" IntegerLiteral /* xgc: reserved-function-namesXQ30 */
[166]	InlineFunction	::=	"function" "(" ParamList? ")" ("as" SequenceType)? EnclosedExpr
[167]	SingleType	::=	AtomicOrUnionType "?"?
[168]	TypeDeclaration	::=	"as" SequenceType
[169]	SequenceType	::=	("empty-sequence" "(" ")") | (ItemType OccurrenceIndicator?)
[170]	OccurrenceIndicator	::=	"?" | "*" | "+" /* xgc: occurrence-indicatorsXQ30 */
[171]	ItemType	::=	KindTest | ("item" "(" ")") | FunctionTest | AtomicOrUnionType | ParenthesizedItemType
[172]	AtomicOrUnionType	::=	EQName
[173]	KindTest	::=	DocumentTest | ElementTest | AttributeTest | SchemaElementTest | SchemaAttributeTest | PITest | CommentTest | TextTest | NamespaceNodeTest | AnyKindTest
[174]	AnyKindTest	::=	"node" "(" ")"
[175]	DocumentTest	::=	"document-node" "(" (ElementTest | SchemaElementTest)? ")"
[176]	TextTest	::=	"text" "(" ")"
[177]	CommentTest	::=	"comment" "(" ")"
[178]	NamespaceNodeTest	::=	"namespace-node" "(" ")"
[179]	PITest	::=	"processing-instruction" "(" (NCName | StringLiteral)? ")"
[180]	AttributeTest	::=	"attribute" "(" (AttribNameOrWildcard ("," TypeName)?)? ")"
[181]	AttribNameOrWildcard	::=	AttributeName | "*"
[182]	SchemaAttributeTest	::=	"schema-attribute" "(" AttributeDeclaration ")"
[183]	AttributeDeclaration	::=	AttributeName
[184]	ElementTest	::=	"element" "(" (ElementNameOrWildcard ("," TypeName "?"?)?)? ")"
[185]	ElementNameOrWildcard	::=	ElementName | "*"
[186]	SchemaElementTest	::=	"schema-element" "(" ElementDeclaration ")"
[187]	ElementDeclaration	::=	ElementName
[188]	AttributeName	::=	EQName
[189]	ElementName	::=	EQName
[190]	TypeName	::=	EQName
[191]	FunctionTest	::=	Annotation* (AnyFunctionTest | TypedFunctionTest)
[192]	AnyFunctionTest	::=	"function" "(" "*" ")"
[193]	TypedFunctionTest	::=	"function" "(" (SequenceType ("," SequenceType)*)? ")" "as" SequenceType
[194]	ParenthesizedItemType	::=	"(" ItemType ")"
[195]	URILiteral	::=	StringLiteral
[196]	EQName	::=	QName | (URILiteral ":" NCName) /* ws: explicitXQ30 */
